# 事务

## 概念
数据库中一组原子性操作的集合，通过ACID特性（原子性、一致性、隔离性、持久性）保证数据在并发或异常场景下的完整性。

## 核心原理
- **原子性（Atomicity）**：通过undo日志实现，事务执行失败时回滚到初始状态；
- **一致性（Consistency）**：依赖约束（如唯一索引）和应用逻辑，确保事务前后数据符合业务规则；
- **隔离性（Isolation）**：通过锁（行锁、间隙锁）和MVCC（多版本并发控制）控制并发事务间的可见性；
- **持久性（Durability）**：通过redo日志实现，事务提交后即使宕机也可通过日志恢复数据。

## 背景
电商订单支付、金融转账等场景需要保证多操作的整体成功或失败（如扣库存与扣余额需同时完成），传统单操作无法满足，因此引入事务机制。

## 解决的问题
- 部分成功：避免库存扣减但支付失败导致的超卖；
- 数据不一致：并发事务修改同一数据时可能出现以下问题及解决方案：
  - **脏读**：事务A读取到事务B未提交的修改（如事务B更新库存为100但未提交，事务A读取到100，随后事务B回滚，实际库存仍为200）。解决：设置事务隔离级别为`读已提交（RC）`（默认`REPEATABLE READ`可通过`SET TRANSACTION ISOLATION LEVEL READ COMMITTED`调整）；
  - **不可重复读**：事务A两次读取同一数据得到不同结果（如事务A首次读库存为200，事务B提交更新为150，事务A再次读得150）。解决：使用`可重复读（RR）`隔离级别（InnoDB默认），通过MVCC生成快照保证一致性；
  - **幻读**：事务A根据查询结果执行操作时，事务B插入新数据导致结果集变化（如事务A查询`age>20`的用户有10条，事务B插入1条，事务A再次查询得到11条）。解决：升级隔离级别为`串行化（SERIALIZABLE）`（强制事务串行执行），或使用`SELECT ... FOR UPDATE`加锁阻止插入；
  - **锁竞争**：高并发写操作导致行锁/表锁等待（如100个事务同时更新同一商品库存）。解决：优化索引减少锁范围（如通过商品ID快速定位行锁），拆分大事务为小批次提交（每次更新100条）；
  - **死锁**：事务A持有记录1的锁并请求记录2，事务B持有记录2的锁并请求记录1。解决：设置`innodb_lock_wait_timeout=5`（默认50秒）自动回滚超时事务，调整事务执行顺序（如统一按ID升序更新记录）。
- 系统崩溃：确保已提交事务的数据在重启后不丢失。

## 执行流程
1. 开启事务：`START TRANSACTION;`或`BEGIN;`；
2. 执行操作：执行`INSERT/UPDATE/DELETE`等语句；
3. 提交/回滚：成功则`COMMIT;`，失败则`ROLLBACK;`（Go中通过`sql.Tx.Commit()`/`sql.Tx.Rollback()`实现）。

## 注意事项（Go面试相关）
- Go中使用`database/sql`的`Begin()`开启事务，需注意`Tx`对象生命周期（避免长时间未提交占用锁）；
- 高并发场景中，事务隔离级别（如读已提交）需权衡一致性与性能（Go应用可通过`SET TRANSACTION ISOLATION LEVEL`调整）；
- 避免大事务（如包含1000+条更新），否则可能导致锁等待超时（Go中建议拆分为多个小事务）；
- 事务中涉及跨库操作（如同时修改MySQL和Redis），需结合补偿机制（如本地消息表）实现最终一致性。

## 使用场景
- 电商下单：扣库存+生成订单+扣余额（需原子性）；
- 金融转账：A账户扣款+B账户加款（需一致性）；
- 日志记录：操作成功时记录日志，失败时回滚（需持久性）；
- 并发秒杀：通过行锁（InnoDB）防止超卖（需隔离性）。