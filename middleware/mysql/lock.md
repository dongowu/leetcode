## 锁

#### 基础原理
##### 分类
  - 操作类型
    - 读锁
      - 概念：共享锁,称为读锁，读读兼容，当前事务添加s锁后，其他事务也可以获得s锁，但是会阻塞X锁的建立；针对同一份数据读操作可以同时加上多个读锁， 互不影响 添加X锁 需要等s锁全部释放
    - 写锁
      - 概念: 排他锁，读写/写写不兼容，当前事务获取X锁后，会阻塞其他事务获取S/X锁，当事务A加了X锁后，可对记录读和写操作，但是其他事务不做读和修改操作
    - 意向锁[表级锁]
      - IS：意向共享锁，表级锁 已加S锁的表 那么一定会有IS锁
      - IX：意向排他锁 表级锁，已加X锁的表，肯定会又IX锁


    |操作 |       锁的模式    |            说明|
    |------|---------|-----------|
    |普通select语句 |无锁| 无锁，  基于MVCC机制，普通的 select 语句属于快照读|
    |select…lock in share mode|S|当前读，显示(explicit)读锁， 上锁后，其它事务对锁定的索引记录仍可以上S锁，但阻塞其它事务对锁定的索引记录上X锁|
    |select…for update|X|显式(explicit)写锁，上锁后，阻塞其它事务对锁定的索引记录上S或X锁|
    |insert/update/delete|X|隐式(implicit)写锁，上锁后，阻塞其它事务对锁定的索引记录上S或X锁|

  - 锁粒度
    - 表级锁
      - 概念：每次操作都锁定整张表，锁的粒度大，表级锁 并发度低
      - 特点：开销小 加锁快，不会出现死锁，锁粒度大 发生冲突概率低并发度低
    - 行级锁
      - 概念：每次操作都锁住一行记录，锁的粒度最小，发生锁冲突的概率最低，并发度最高 应用在innodb引擎的存储引擎中
      - 特点：开销大 加锁慢 会出现死锁 锁定粒度小 发生锁冲突概率大 并发度高，innodb的行锁是实现在索引上的，不是所在行物理记录上的
      - 只有通过索引条件检索出来的数据，innodb才会使用行级锁，否则使用表锁（锁膨胀）
  - innodb 存储引擎三种行锁模式
   > InnoDB引擎 的  行锁  是对 记录加锁实现的。InnoDB引擎 的  行锁  主要 有 3 种：Record Lock、Gap Lock 和 Next-key Lock,也就是InnoDB的三种行锁模式。
    - RecordLock
      - 概念：锁定单个行记录的锁 RC，RR隔离级别都支持
      - 描述：记录所仅锁住索引记录的一行，在单条记录上加锁
           record lock 锁住的永远是索引 而非记录本身
           即使表上没有任何的索引，那么innodb会后台创建一个隐藏的聚集主键索引 那么锁住的就是这个隐藏字段
           当一条sql 没走任何索引时，那么将会在每一条聚合索引后面加X锁，类似于表锁 但是原理和表锁完全不同

    - Gap Lock：
      - 概念：间隙锁 ，锁定索引记录间隙 确保索引记录的间隙不变
             Gap是范围锁，RR隔离级别支持，RC隔离级别不支持
      - 描述：区间锁 仅锁住一个索引区间，开区间
             在索引记录之间的间隙加锁，或者在某一条索引记录之前或者之后加锁，并不包括该索引记录本身；间隙锁可用于防止幻读，保证索引间 不会被插入数据
    - Next-key Lock（临建锁）
    记录锁+间隙锁组合 同时锁住数据 并锁住数据的前后范围
    RR隔离级别支持 RC隔离级别不支持
    （1）临键锁= 记录锁+范围锁 。    临键锁(Next-Key Locks)  =   gap lock   +  record lock, 左开右闭区间。
    （2）默认情况下，innodb 事务的隔离级别是 RR  不是RC，所以  select … for update 默认 使用next-key locks来锁定记录。
    （3）但当查询的索引含有唯一属性的时候，Next-Key Lock 会进行优化，将其降级为Record Lock，即仅锁住索引本身，不是范围。
    （4）Next-Key Lock在不同的场景中会退化

  - 快照读和当前读
    - 快照读: 简单的select操作 属于快照读 一般不加锁
      - 底层原理：
          基于 数据快照   undo-log去读， 不是 直接访问物理存储的最新数据版本 ，或者说 不是 直接访问 Buffer Pool  缓冲池  数据页（Data Buffer ）  的最新数据版本
          读取的是历史版本数据  或者说，读的是 Buffer Pool  缓冲池 的 Undo页（Undo Buffer ）数据，不感知其他事务的后续修改
      - 实现:
        Mysql中的快照读是通过MVCC+undolog实现的。 
        快照读，顾名思义，就是读取快照数据，也就是说当某个数据正在被修改的时候，也可以进行读取该数据，保证读写不冲突。 
        mysql中的快照读 ,  每次都是读取undolog中的数据。 
          - undolog，当我们对记录做了变更操作时，就会产生undo记录，undo记录中存储的是老版数据，当一个旧的事务需要读取数据时，为了能够读取到老版本的数据，需要顺着undo列找到满足其可见性的记录，这个找满足可见行的记录依赖。 
          - MVVC
             - MVCC也称多版本并发控制，说的通俗易懂一点就是记录数据的不同版本。
             -  不同事务或者相同事务的对同一记录的修改，会导致该记录的undo log成为一条记录版本线性表，既链表，undo log的链首就是最新的旧记录，链尾就是最早的旧记录。
             - 快照读都是去读取undolog中链首的最新的旧记录。
          但是MVVC在不同隔离级别下 读取的内容不一致，导致不同隔离级别下的快照读不一样
          - 在RC隔离界别下 快照读与当前读的数据一致,在RC级别下快照读读取的时undolog的链首的最新记录
           举例：
           以下为事务A和事务B的执行过程泳道图：

          | 时间线 | 事务A（隔离级别：RC） | 事务B（隔离级别：RC） | 数据状态（name字段） |
          |--------|---------------------|---------------------|---------------------|
          | T1     | 开始事务            | -                   | 初始值：张三        |
          | T2     | 执行SELECT（快照读） | -                   | 读取结果：张三      |
          | T3     | -                   | 开始事务            | -                   |
          | T4     | -                   | 执行UPDATE（当前读） | 临时修改为李四（未提交） |
          | T5     | -                   | 提交事务            | 最终值：李四        |
          | T6     | 执行SELECT（快照读） | -                   | 读取结果：李四（基于已提交的Undo日志） |
          | T7     | 提交事务            | -                   | -                   |
          当前读 在事务B中 执行Update操作，添加X锁，其他事务无法读取该数据，那么当B 提交了事务后,A再次读取读取 读取的是 undolog的最新数据
          - 在RR隔离级别下，在一个事务内，读取的都是第一次select的数据（首次快照读生成快照），后续查询不会感知其他事务已提交的修改，因此可能会出现读取的数据不是最新数据的情况。

          以下为事务A和事务B的执行过程泳道图（隔离级别：RR）：

          | 时间线 | 事务A（隔离级别：RR） | 事务B（隔离级别：RR） | 数据状态（name字段） |
          |--------|---------------------|---------------------|---------------------|
          | T1     | 开始事务            | -                   | 初始值：张三        |
          | T2     | 执行SELECT（快照读） | -                   | 读取结果：张三（生成首次快照） |
          | T3     | -                   | 开始事务            | -                   |
          | T4     | -                   | 执行UPDATE（当前读） | 临时修改为李四（未提交） |
          | T5     | -                   | 提交事务            | 最终值：李四        |
          | T6     | 执行SELECT（快照读） | -                   | 读取结果：张三（使用首次生成的快照） |
          | T7     | 提交事务            | -                   | -                   |
          **事务的不同隔离级别加锁方式是不同的**
           1、可重复读（RR）：
           在RR隔离级别下，默认会使用Next-Key Locks，这是Record Lock加上Gap Lock的组合。它的作用是防止幻读现象，即阻止其他事务插入新的记录到当前事务正在读取的范围之内。
           2、 读已提交（RC）：
            与RR不同，在RC隔离级别下，默认情况下不会使用Gap Locks，这意味着它不会阻止其他事务向当前事务正在操作的数据范围内插入新记录。因此，在RC隔离级别下可能会出现幻读现象。

    - 当前读：特殊的读操作，插入/更新/删除操作，属于当前读，需要加锁。
     > SELECT ... LOCK IN SHARE MODE：
    会给读取到的记录加上共享锁（S锁），允许其他事务也获取这些记录的S锁，但阻止X锁。
     > SELECT ... FOR UPDATE、INSERT、UPDATE、DELETE：
    会给涉及的记录加上排他锁（X锁），阻止其他任何事务获取这些记录的任何类型的锁。
      - 底层原理:
        直接访问物理存储的最新数据版本 ， 或者说  直接访问 Buffer Pool  缓冲池  数据页（Data Buffer ）  的最新数据版本
        总是读取其他事务已提交的最新修改
      - 实现:
        Mysql实现当前读是通过 共享锁+排他锁+Next-Key Lock实现的。
          每次对行数据进行读取的时候，加共享锁。此时就不允许修改，但是允许其他事务读取，所以每次都可以读到最新的数据。
          每次对行数据进行修改的时候，加排他锁，不允许其他事务读取和修改。这种情况下其他事务读取的数据也一定是最新的数据。
          每次对范围行数据进行读取的时候，对这个范围加一个范围共享锁。
          每次对范围行数据进行修改的时候，读这个范围加一个范围排它锁。
      
     -  MySQL  Buffer Pool  缓冲池中的组件详解 
       在MySQL的InnoDB存储引擎中，缓冲池（Buffer Pool）是一个关键的内存结构，用于缓存数据和索引，以减少对物理磁盘的I/O操作。以下是缓冲池中一些重要组件的详细解释： 
        1. 索引页（Index Pages） 索引页存储了InnoDB表的索引结构，包括主键索引（聚集索引）和辅助索引（非聚集索引）。这些索引页被加载到缓冲池中，以加速对表中数据的查找和访问。当执行查询操作时，InnoDB会首先检查所需的索引页是否已经在缓冲池中，如果在，则直接从缓冲池中读取，这称为缓冲池命中；如果不在，则需要从磁盘加载到缓冲池中，这称为缓冲池未命中。 
        2. 数据页（Data Pages） 数据页存储了InnoDB表的实际数据行。在InnoDB中，数据是按页存储的，每个数据页通常包含多行数据。当需要读取或修改表中的数据时，相关的数据页会被加载到缓冲池中。通过将数据页缓存在内存中，InnoDB可以快速地读取和修改数据，而无需每次都从磁盘加载。 3. Undo页（Undo Pages） Undo页存储了旧版本的数据，用于支持事务的ACID属性中的隔离性（Isolation）和持久性（Durability）。当执行一个事务时，对数据的修改不会立即生效，而是先记录在Undo页中。如果其他事务需要读取被修改的数据，它可以通过Undo页来获取数据修改前的版本，从而实现多版本并发控制（MVCC）。此外，如果事务失败或回滚，Undo页中的数据可以用于恢复数据到事务开始前的状态。 
        4. 插入缓存（Insert Buffer） 插入缓存是InnoDB中用于优化非聚集索引插入操作的一种机制。当向一个包含非聚集索引的表中插入数据时，如果相关的索引页不在缓冲池中，InnoDB不会立即将索引键插入到索引页中，而是将其存储在插入缓存中。当相关的索引页被加载到缓冲池时，插入缓存中的索引键会被合并并插入到索引页中。这样可以减少磁盘I/O操作，并提高插入操作的性能。 
        需要注意的是，插入缓存只适用于非唯一索引的插入操作，并且在某些情况下，如缓冲池足够大或表很小，插入缓存可能不会被使用。



  
  -  锁膨胀/锁优化分析之一： 索引等值匹配  加锁规则
      - 锁膨胀/锁优化分析 分为两种情况：
        1、 ***索引等值匹配*** : 有唯一性的索引，都会降级为Record Lock。 当查询的索引含有唯一属性的时候，Next-Key Lock 会进行优化，将其降级为Record Lock，即仅锁住索引本身，不是范围。
          - 分析: 聚簇索引 唯一索引 普通索引 等于条件的修改语句加锁情况
             - 聚簇索引:针对唯一匹配的索引记录上 加recordLock, 这是Next-key Lock 降级为RecordLock
             - 唯一索引: 针对唯一匹配的索引记录上 加recordLock,对应的 聚集索引记录也上了Record Lock，都是Next-key Lock降级优化为 Record Lock
             - 普通索引：对所有匹配的 索引记录 都上了 Next-key Lock，对应的聚族索引记录 都上了Record Lock， 另外，对匹配索引记录的next key记录上了Gap Lock。（相当于把自身和前后的间隙都加锁了），原因是普通索引可能重复，需要向右扫描
        2、*** 索引无值匹配*** ：对于聚集索引、唯一索引、普通索引，都只上了一把Gap Lock间隙锁，锁的是 若条件值成立 的 next key索引记录。

       不同索引类型下 索引等值与 索引不等值的区别
        - RR隔离级别、**聚簇索引**下:
         索引等值 那么锁会锁住这一行数据， next-key lock 会降级为record lock
         索引不等值时,那么锁住大于此值的这个范围，next-key lock 降级为gap lock
        - **唯一索引下**: [添加了两把锁]
          索引等值,那么因为时唯一一条记录,是无间隙的record lock，也是Next-key lock降级为record lock
          索引不等值, 唯一索引时，行级锁会上一把 间隙锁，与聚集索引规则相同
        - **普通索引**:
          索引等值,