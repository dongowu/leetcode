## 锁

#### 基础原理
##### 分类
  - 操作类型
    - 读锁
      - 概念：共享锁,称为读锁，读读兼容，当前事务添加s锁后，其他事务也可以获得s锁，但是会阻塞X锁的建立；针对同一份数据读操作可以同时加上多个读锁， 互不影响 添加X锁 需要等s锁全部释放
    - 写锁
      - 概念: 排他锁，读写/写写不兼容，当前事务获取X锁后，会阻塞其他事务获取S/X锁，当事务A加了X锁后，可对记录读和写操作，但是其他事务不做读和修改操作
    - 意向锁[表级锁]
      - IS：意向共享锁，表级锁 已加S锁的表 那么一定会有IS锁
      - IX：意向排他锁 表级锁，已加X锁的表，肯定会又IX锁


    |操作 |       锁的模式    |            说明|
    |------|---------|-----------|
    |普通select语句 |无锁| 无锁，  基于MVCC机制，普通的 select 语句属于快照读|
    |select…lock in share mode|S|当前读，显示(explicit)读锁， 上锁后，其它事务对锁定的索引记录仍可以上S锁，但阻塞其它事务对锁定的索引记录上X锁|
    |select…for update|X|显式(explicit)写锁，上锁后，阻塞其它事务对锁定的索引记录上S或X锁|
    |insert/update/delete|X|隐式(implicit)写锁，上锁后，阻塞其它事务对锁定的索引记录上S或X锁|

  - 锁粒度
    - 表级锁
      - 概念：每次操作都锁定整张表，锁的粒度大，表级锁 并发度低
      - 特点：开销小 加锁快，不会出现死锁，锁粒度大 发生冲突概率低并发度低
    - 行级锁
      - 概念：每次操作都锁住一行记录，锁的粒度最小，发生锁冲突的概率最低，并发度最高 应用在innodb引擎的存储引擎中
      - 特点：开销大 加锁慢 会出现死锁 锁定粒度小 发生锁冲突概率大 并发度高，innodb的行锁是实现在索引上的，不是所在行物理记录上的
      - 只有通过索引条件检索出来的数据，innodb才会使用行级锁，否则使用表锁（锁膨胀）
  - innodb 存储引擎三种行锁模式
   > InnoDB引擎 的  行锁  是对 记录加锁实现的。InnoDB引擎 的  行锁  主要 有 3 种：Record Lock、Gap Lock 和 Next-key Lock,也就是InnoDB的三种行锁模式。
    - RecordLock
      - 概念：锁定单个行记录的锁 RC，RR隔离级别都支持
      - 描述：记录所仅锁住索引记录的一行，在单条记录上加锁
           record lock 锁住的永远是索引 而非记录本身
           即使表上没有任何的索引，那么innodb会后台创建一个隐藏的聚集主键索引 那么锁住的就是这个隐藏字段
           当一条sql 没走任何索引时，那么将会在每一条聚合索引后面加X锁，类似于表锁 但是原理和表锁完全不同

    - Gap Lock：
      - 概念：间隙锁 ，锁定索引记录间隙 确保索引记录的间隙不变
             Gap是范围锁，RR隔离级别支持，RC隔离级别不支持
      - 描述：区间锁 仅锁住一个索引区间，开区间
             在索引记录之间的间隙加锁，或者在某一条索引记录之前或者之后加锁，并不包括该索引记录本身；间隙锁可用于防止幻读，保证索引间 不会被插入数据
    - Next-key Lock（临建锁）
    记录锁+间隙锁组合 同时锁住数据 并锁住数据的前后范围
    RR隔离级别支持 RC隔离级别不支持
    （1）临键锁= 记录锁+范围锁 。    临键锁(Next-Key Locks)  =   gap lock   +  record lock, 左开右闭区间。
    （2）默认情况下，innodb 事务的隔离级别是 RR  不是RC，所以  select … for update 默认 使用next-key locks来锁定记录。
    （3）但当查询的索引含有唯一属性的时候，Next-Key Lock 会进行优化，将其降级为Record Lock，即仅锁住索引本身，不是范围。
    （4）Next-Key Lock在不同的场景中会退化

  - 快照读和当前读
    - 快照读: 简单的select操作 属于快照读 一般不加锁
