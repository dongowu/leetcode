# 范式

## 概念
数据库设计的规范化理论，通过逐步消除数据冗余和更新异常，定义表结构的设计规则（如1NF、2NF、3NF、BCNF等）。

## 核心原理
- **1NF**：列不可再分（如不允许存储数组类型）；
- **2NF**：消除非主属性对候选键的部分依赖（如订单表中订单ID+商品ID为联合主键，商品单价应依赖于商品ID而非联合主键）；
- **3NF**：消除非主属性对候选键的传递依赖（如员工表中部门地址不应通过部门ID间接依赖于员工ID）；
- **BCNF**：消除主属性间的传递依赖（如仓库管理表中仓库ID→管理员，管理员→仓库ID时需拆表）。

## 背景
早期数据库设计因冗余导致插入/更新/删除异常（如修改部门地址需更新所有该部门员工记录），需通过范式约束表结构。

## 解决的问题
- 插入异常：无法插入未完全填充字段的记录（如无员工时无法插入新部门）；
- 更新异常：修改某字段需更新多条记录（如部门地址变更需批量操作）；
- 删除异常：删除某记录导致其他信息丢失（如删除最后一个员工记录时丢失部门信息）。

## 执行流程
1. 需求分析：确定业务实体（如用户、订单、商品）；
2. 初始建模：设计包含所有字段的大表（如用户订单表）；
3. 逐步规范化：按1NF→2NF→3NF顺序拆分表（如拆分为用户表、订单表、商品表）；
4. 反范式优化：根据查询性能需求适当冗余（如订单表中冗余用户姓名减少JOIN）。

## 注意事项（Go面试相关）
- Go ORM框架（如GORM）映射表结构时需确保符合范式，避免自动生成冗余字段；
- 高并发场景中严格遵循3NF可能导致多表JOIN性能问题，需结合缓存（如Redis）或反范式设计；
- 设计Go微服务数据库时，不同服务的库表需独立遵循范式（如用户服务与订单服务的用户信息不共享同一表）。

## 使用场景
- 基础业务表设计（如用户表、商品表强制3NF）；
- 日志表/统计临时表可适当反范式（如冗余用户ID和姓名避免JOIN）；
- 微服务间数据库隔离（每个服务库表独立遵循范式，避免跨库JOIN）。