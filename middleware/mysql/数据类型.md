# 数据类型

## 概念
MySQL中用于定义列存储数据的类型规范，决定数据存储格式和操作行为。

## 核心原理
根据数据特征（数值范围、精度、存储效率）划分类型，如整数类型（INT/BIGINT）、浮点类型（FLOAT/DOUBLE）、字符串类型（VARCHAR/TEXT）、日期类型（DATETIME/TIMESTAMP）等。

## 背景
不同业务场景对数据存储有差异化需求（如用户年龄用INT，长文本用TEXT），需通过类型约束保证数据有效性和存储效率。

## 解决的问题
避免数据混乱（如用INT存手机号导致溢出），优化存储（如用TINYINT存布尔值），支持特定操作（如DATE类型支持日期函数）。

## 执行流程
1. 建表时通过`CREATE TABLE`指定列类型（如`age INT`）；
2. 插入数据时自动校验类型匹配（如字符串无法插入INT列）；
3. 查询时按类型解析数据（如DATETIME返回格式化日期）。

## 注意事项（Go面试相关）
- Go中通过`database/sql`驱动映射MySQL类型时，需注意`NULL`值处理（使用`sql.NullString`等类型）；
- 避免使用`TEXT`存短字符串（改用VARCHAR减少IO），Go中读取大TEXT字段建议流式处理；
- TIMESTAMP与DATETIME在Go中解析时需注意时区问题（推荐统一用UTC）。

## 使用场景及原因
### 1. 整数类型（TINYINT/INT/BIGINT）
- 场景：用户年龄（TINYINT）、商品库存（INT）、订单ID（BIGINT）。
- 原因：
  - TINYINT（0-255）适合年龄等小范围数值，节省存储空间（仅1字节）；
  - INT（-2^31~2^31-1）覆盖大多数业务计数需求（4字节）；
  - BIGINT（-2^63~2^63-1）用于高并发场景的自增ID（8字节，避免溢出）。

### 2. 字符串类型（VARCHAR/TEXT）
- 场景：用户名（VARCHAR(255)）、商品详情（TEXT）、长评论（LONGTEXT）。
- 原因：
  - VARCHAR（最大65535字节）存储短文本，可变长度节省空间，支持索引；
  - TEXT（最大64KB）存储长文本（如商品描述），不建议索引（影响性能）；
  - LONGTEXT（最大4GB）用于超长篇幅（如日志内容）。

### 3. 日期时间类型（DATETIME/TIMESTAMP）
- 场景：订单创建时间（DATETIME）、用户最后登录时间（TIMESTAMP）。
- 原因：
  - DATETIME（范围1000-01-01 ~ 9999-12-31）存储绝对时间，不依赖时区；
  - TIMESTAMP（范围1970-01-01 ~ 2038-01-19）自动转换为UTC存储，适合需要时区感知的场景（如多地区业务）。

### 4. 浮点/定点类型（FLOAT/DOUBLE/DECIMAL）
- 场景：商品评分（FLOAT）、科学计算（DOUBLE）、金额（DECIMAL）。
- 原因：
  - FLOAT（4字节）精度低（约7位有效数字），适合对精度要求不高的场景；
  - DOUBLE（8字节）精度更高（约15位有效数字），用于科学计算；
  - DECIMAL（自定义精度）精确存储数值（如金额），避免浮点误差（金融场景必选）。

## 避坑点
### 1. 整数溢出
- 避免用TINYINT存超过255的值（如用TINYINT存用户年龄时，需限制输入≤255）；
- 高并发系统中，自增ID建议用BIGINT（INT最大约21亿，可能因数据量增长导致溢出）。

### 2. 字符串类型滥用
- VARCHAR长度设置需合理（如用户名设为VARCHAR(50)而非VARCHAR(255)，减少存储和索引开销）；
- 避免用TEXT存短文本（如评论内容≤255字符时，改用VARCHAR以支持索引加速查询）。

### 3. 浮点精度问题
- 金融场景禁止使用FLOAT/DOUBLE（如1.00-0.99可能得到0.009999999而非0.01），必须用DECIMAL(10,2)。

### 4. TIMESTAMP的隐式时区转换
- 若业务需跨时区展示时间，需明确设置会话时区（`SET time_zone = '+8:00'`），避免TIMESTAMP自动转换导致混乱。

### 5. ENUM类型的维护成本
- ENUM（如'未支付','已支付'）修改枚举值需执行`ALTER TABLE`，影响在线服务，建议用整型+字典表替代。