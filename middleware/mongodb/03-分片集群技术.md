# MongoDB 分片集群技术

## 背景介绍

分片（Sharding）是MongoDB的水平扩展解决方案，通过将数据分布到多个服务器上来处理大数据量和高并发访问。

### 设计目标
- **水平扩展**：突破单机存储和性能限制
- **负载分散**：将读写负载分布到多个节点
- **透明访问**：应用程序无需感知分片逻辑
- **弹性扩容**：支持动态添加和删除分片

## 核心原理

### 1. 分片集群架构
```
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│   mongos    │    │   mongos    │    │   mongos    │
│  (路由层)    │    │  (路由层)    │    │  (路由层)    │
└─────────────┘    └─────────────┘    └─────────────┘
       │                   │                   │
       └───────────────────┼───────────────────┘
                          │
    ┌─────────────────────┼─────────────────────┐
    │                     │                     │
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│   Shard 1   │    │   Shard 2   │    │   Shard 3   │
│ (副本集1)    │    │ (副本集2)    │    │ (副本集3)    │
└─────────────┘    └─────────────┘    └─────────────┘
                          │
                ┌─────────────────────┐
                │   Config Servers   │
                │   (配置服务器)       │
                │    (副本集)         │
                └─────────────────────┘
```

### 2. 核心组件

#### mongos（查询路由器）
- **作用**：客户端访问入口，路由查询到正确分片
- **功能**：
  - 查询路由和结果聚合
  - 负载均衡
  - 缓存元数据
  - 处理分布式事务

#### Config Servers（配置服务器）
- **作用**：存储分片集群的元数据
- **数据内容**：
  - 分片键范围（chunk）信息
  - 分片节点信息
  - 数据库和集合的分片配置
  - 平衡器状态

#### Shard（分片）
- **作用**：实际存储数据的节点
- **实现**：通常是副本集，提供高可用性
- **特点**：每个分片存储数据的一个子集

### 3. 分片策略

#### 范围分片（Range Sharding）
- **原理**：根据分片键值的范围分布数据
- **优点**：范围查询效率高
- **缺点**：可能导致热点问题

```javascript
// 示例：按年龄范围分片
// Shard 1: age [0, 30)
// Shard 2: age [30, 60)
// Shard 3: age [60, ∞)
```

#### 哈希分片（Hash Sharding）
- **原理**：对分片键进行哈希运算后分布数据
- **优点**：数据分布均匀，避免热点
- **缺点**：范围查询效率低

```javascript
// 示例：按用户ID哈希分片
// hash(userId) % 3 决定分片
```

#### 标签分片（Tag-based Sharding）
- **原理**：基于标签将数据路由到指定分片
- **用途**：地理位置分片、硬件分层等

## 技术亮点

### 1. 自动平衡
- **平衡器**：自动检测数据分布不均
- **chunk迁移**：自动迁移数据块平衡负载
- **最小影响**：迁移过程不影响正常读写

### 2. 透明扩展
- **动态分片**：运行时添加新分片
- **自动路由**：mongos自动路由到正确分片
- **应用透明**：应用程序无需修改

### 3. 高性能
- **并行处理**：查询可在多个分片并行执行
- **本地化访问**：数据就近访问
- **索引分布**：每个分片维护自己的索引

## 分片键设计

### 1. 分片键选择原则

#### 高基数（High Cardinality）
- **定义**：分片键有足够多的不同值
- **目的**：支持更多的chunk分割
- **示例**：用户ID、订单ID

#### 低频率（Low Frequency）
- **定义**：避免某个值出现频率过高
- **目的**：防止单个chunk过大
- **反例**：状态字段（只有几个值）

#### 非单调性（Non-Monotonic）
- **定义**：避免分片键单调递增
- **目的**：防止写入热点
- **反例**：时间戳、自增ID

### 2. 常见分片键模式

#### 复合分片键
```javascript
// 用户ID + 时间戳
{ "userId": 1, "timestamp": 1 }

// 地区 + 类别
{ "region": 1, "category": 1 }
```

#### 哈希分片键
```javascript
// 对单个字段进行哈希
{ "userId": "hashed" }
```

#### 标签分片键
```javascript
// 基于地理位置
{ "country": 1, "city": 1 }
```

### 3. 分片键限制
- **不可变性**：分片键值不能修改
- **索引要求**：分片键必须有索引
- **大小限制**：分片键值不能超过512字节
- **类型限制**：不支持数组类型作为分片键

## 数据分布与管理

### 1. Chunk（数据块）
- **定义**：分片中数据的逻辑单元
- **大小**：默认64MB，可配置
- **范围**：由分片键值范围定义

#### Chunk生命周期
```javascript
// 1. 初始chunk
{ "_id": "mydb.mycoll-_id_MinKey", 
  "min": { "_id": MinKey }, 
  "max": { "_id": MaxKey },
  "shard": "shard0001" }

// 2. 分裂后的chunk
{ "_id": "mydb.mycoll-_id_MinKey", 
  "min": { "_id": MinKey }, 
  "max": { "_id": ObjectId("...") },
  "shard": "shard0001" }

{ "_id": "mydb.mycoll-_id_ObjectId(...)", 
  "min": { "_id": ObjectId("...") }, 
  "max": { "_id": MaxKey },
  "shard": "shard0001" }
```

### 2. 平衡器（Balancer）
- **作用**：维护集群数据分布平衡
- **触发条件**：分片间chunk数量差异超过阈值
- **迁移过程**：
  1. 选择源和目标分片
  2. 复制chunk到目标分片
  3. 更新元数据
  4. 删除源分片数据

#### 平衡器配置
```javascript
// 启用/禁用平衡器
sh.setBalancerState(true);
sh.setBalancerState(false);

// 设置平衡窗口
sh.setBalancerState(true);
db.settings.update(
   { _id: "balancer" },
   { $set: { activeWindow : { start : "23:00", stop : "6:00" } } },
   { upsert: true }
);
```

### 3. 分片操作

#### 启用分片
```javascript
// 1. 启用数据库分片
sh.enableSharding("mydb");

// 2. 创建分片键索引
db.mycoll.createIndex({ "userId": 1 });

// 3. 对集合进行分片
sh.shardCollection("mydb.mycoll", { "userId": 1 });
```

#### 添加分片
```javascript
// 添加新分片（副本集）
sh.addShard("rs1/mongo1:27017,mongo2:27017,mongo3:27017");
```

#### 移除分片
```javascript
// 1. 开始排空分片
db.runCommand({ "removeShard": "shard0001" });

// 2. 检查排空状态
db.runCommand({ "removeShard": "shard0001" });

// 3. 完成移除
db.runCommand({ "removeShard": "shard0001" });
```

## 查询路由

### 1. 查询类型

#### 目标查询（Targeted Query）
- **定义**：查询条件包含分片键
- **路由**：直接路由到特定分片
- **性能**：最高效的查询方式

```javascript
// 包含分片键的查询
db.users.find({ "userId": 12345 });
```

#### 广播查询（Broadcast Query）
- **定义**：查询条件不包含分片键
- **路由**：需要查询所有分片
- **性能**：效率较低，应尽量避免

```javascript
// 不包含分片键的查询
db.users.find({ "email": "user@example.com" });
```

### 2. 聚合操作

#### 管道优化
- **$match前置**：尽早过滤数据
- **分片键过滤**：利用分片键减少扫描范围
- **本地聚合**：在各分片本地执行部分聚合

```javascript
// 优化的聚合管道
db.orders.aggregate([
  { $match: { "userId": 12345, "status": "completed" } }, // 包含分片键
  { $group: { _id: "$productId", total: { $sum: "$amount" } } },
  { $sort: { total: -1 } },
  { $limit: 10 }
]);
```

## 使用场景

### 1. 大数据量场景
- **海量数据存储**：TB级别数据存储
- **高并发访问**：大量并发读写请求
- **快速增长**：数据量快速增长的应用

### 2. 地理分布
- **多地部署**：数据就近存储和访问
- **合规要求**：数据本地化存储要求
- **延迟优化**：减少跨地域访问延迟

### 3. 业务隔离
- **多租户系统**：按租户分片隔离数据
- **业务线分离**：不同业务数据分别存储
- **性能隔离**：避免业务间相互影响

## 面试常见问题

### 1. 基础概念
**Q: 分片集群的核心组件及其作用？**
A:
- mongos：查询路由器，负责路由和结果聚合
- Config Servers：存储集群元数据和配置信息
- Shard：实际存储数据的分片节点
- Balancer：负载平衡器，维护数据分布平衡

**Q: 分片键的选择原则？**
A:
- 高基数：足够多的不同值
- 低频率：避免热点值
- 非单调性：避免写入热点
- 查询友好：支持常用查询模式

### 2. 性能优化
**Q: 如何优化分片集群查询性能？**
A:
- 目标查询：查询条件包含分片键
- 索引优化：在各分片创建合适索引
- 聚合优化：合理设计聚合管道
- 避免跨分片JOIN：重新设计数据模型

**Q: 如何处理热点分片问题？**
A:
- 重新选择分片键：避免单调递增键
- 使用复合分片键：增加分布维度
- 哈希分片：使用哈希分片策略
- 预分片：提前创建空chunk

### 3. 运维管理
**Q: 如何安全地添加和移除分片？**
A:
- 添加分片：使用sh.addShard()命令
- 移除分片：先排空数据，再移除节点
- 监控平衡：关注chunk迁移状态
- 业务影响：选择低峰期操作

**Q: 分片集群的监控要点？**
A:
- Chunk分布：监控各分片chunk数量
- 平衡器状态：确保平衡器正常工作
- 查询性能：监控慢查询和跨分片查询
- 连接数：监控mongos连接数

### 4. 故障处理
**Q: 分片节点故障如何处理？**
A:
- 副本集保护：每个分片使用副本集
- 自动故障转移：副本集自动选举新Primary
- 数据恢复：从其他副本恢复数据
- 监控告警：及时发现和处理故障

## 技术分析

### 优势
1. **水平扩展**：突破单机限制，支持PB级数据
2. **高性能**：并行处理，线性性能提升
3. **高可用**：结合副本集，提供高可用性
4. **透明访问**：应用程序无需感知分片逻辑
5. **弹性扩容**：支持在线添加和移除分片

### 劣势
1. **复杂性高**：架构复杂，运维难度大
2. **跨分片限制**：不支持跨分片事务和JOIN
3. **分片键限制**：分片键选择影响性能
4. **资源消耗**：需要更多服务器资源
5. **网络依赖**：对网络稳定性要求高

### 最佳实践
1. **合理规划**：提前规划分片策略和容量
2. **分片键设计**：仔细选择和设计分片键
3. **监控告警**：完善的监控和告警机制
4. **渐进式扩展**：根据业务增长逐步扩展
5. **性能测试**：充分测试分片后的性能表现
6. **备份策略**：制定完整的备份和恢复策略