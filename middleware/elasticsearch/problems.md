# Elasticsearch 常见问题与高频面试题总结

## 一、脑裂（Split Brain）问题
### 1.1 问题原因
- **旧版选举协议缺陷**：ES7以下使用Zen Discovery协议，未强制要求初始主节点列表，当网络分区导致部分节点与主节点断开（心跳超时默认3秒），未连通节点会触发重新选举，原主节点若仍存活则形成双主（多主）集群。
- **网络环境不稳定**：节点间网络延迟波动大（>1秒）或出现临时分区，导致心跳检测误判主节点状态。

### 1.2 影响范围
脑裂会导致集群分裂为2个以上独立小集群，各集群独立写入数据（如主分片分别在不同集群），最终因数据不同步引发：
- 业务层面：客户端请求可能被路由到不同集群，返回矛盾数据（如同一文档出现两个版本）；
- 系统层面：集群状态长期异常，无法进行索引扩容、分片重分配等操作，严重时触发节点熔断（拒绝服务）。

### 1.4 最佳方案
采用『协议+参数』双保险策略：
1. 协议层：升级ES至7.x以上，启用`cluster.initial_master_nodes`明确初始主节点列表（如3个候选主节点）；
2. 参数层：设置`discovery.zen.minimum_master_nodes=2`（3个master节点时），确保仅当至少2个节点连通时才允许选举主节点，从根本上杜绝少数节点形成新主。

### 1.3 解决方案
- **参数约束选举**：设置 `discovery.zen.minimum_master_nodes=(master节点数/2)+1`（如3个master节点设为2），确保仅当多数节点（超过半数）认可时才选举新主，避免少数节点误操作。
- **网络环境加固**：部署独立心跳网络（与业务网络分离），定期用`mtr`工具检测节点间延迟（要求稳定<1秒），避免因网络波动触发误判。
- **协议升级**（ES7+）：通过`cluster.initial_master_nodes`明确初始主节点列表（如`["node-1", "node-2", "node-3"]`），强制集群从指定节点中选举，消除旧版协议的随机性。

### 1.5 使用注意事项
- 网络监控：每周用`mtr --report-wide node-1 node-2 node-3`检测节点间延迟，确保95%以上心跳包延迟<500ms；
- 版本约束：禁止使用ES6及以下版本（Zen Discovery协议），生产环境最低要求ES7.10+（修复了早期选举协议的边界问题）；
- 节点规划：master节点数必须为奇数（推荐3/5个），避免偶数节点数导致“平票”无法选举主节点。

## 二、数据类型问题
### 2.1 字段冲突（Field Conflict）
- **动态映射陷阱**：ES默认动态映射（`dynamic:true`），不同文档同一字段可能被推断为不同类型（如数字与字符串混合），导致索引失败。
- **字段类型不兼容**：手动修改字段类型（如从`text`改为`keyword`）时，需重建索引，否则报`illegal_argument_exception`。

### 2.3 影响范围
字段冲突会直接导致新文档无法写入（报`mapper_parsing_exception`），已存在的旧文档查询时可能返回异常结果（如数字字段被识别为字符串无法排序），严重影响业务数据准确性。

### 2.4 最佳方案
创建索引时直接关闭动态映射（`"dynamic": "strict"`），并通过`PUT /index`显式定义所有字段类型（如`"type": "keyword"`），从源头避免类型冲突。

### 2.2 解决方案
- **显式定义映射（Mapping）**：创建索引时通过`PUT /index`指定字段类型（如`"type": "keyword"`），关闭动态映射（`"dynamic": "strict"`）。
- **字段别名（Field Aliases）**（ES7.6+）：通过`aliases`为字段定义别名，灵活适配多类型查询需求。

### 2.5 使用注意事项
- 上线前用Kibana的`_analyze`接口测试字段分词效果，避免`text`和`keyword`混用；
- 需修改字段类型时，通过`reindex` API重建索引（如`POST /_reindex {"source": {"index": "old"}, "dest": {"index": "new"}}`）；
- 对不确定类型的字段，先用`keyword`类型（可精确匹配），后续根据业务需求再扩展。

## 三、高并发读写问题
### 3.1 分片热点（Shard Hotspot）
- **路由策略不当**：未指定`_routing`时，文档ID哈希分布不均，导致部分分片写入/查询压力过大（如QPS超5万）。
- **副本分片负载不均**：主分片与副本分片分布在同一节点，未充分利用集群资源。

### 3.3 影响范围
分片热点会导致该分片所在节点CPU/内存/磁盘IO飙升，查询延迟从几毫秒增至几百毫秒甚至秒级，严重时触发节点熔断（拒绝服务），影响整体集群稳定性。

### 3.4 最佳方案
根据业务特性选择稳定的路由键（如用户ID后4位、订单创建月份），配合`GET /_cat/shards?v`命令监控分片负载，确保各分片QPS差异不超过20%。

### 3.2 内存压力与延迟
- **内存缓冲区不足**：大批次写入时，内存缓冲区（`indices.memory.index_buffer_size`，默认JVM堆10%）溢出，触发强制刷新（Force Refresh），增加写入延迟（可能从ms级升至s级）。
- **段合并（Segment Merge）**：高并发写入生成大量小段（Segment），触发后台合并任务，占用CPU/IO资源。

### 3.3 优化方案
- **自定义路由**：根据业务维度（如用户ID、订单类型）指定`_routing`，确保分片负载均衡。
- **调整缓冲区大小**：增大`indices.memory.index_buffer_size`（如20%），减少强制刷新频率。
- **限制段合并资源**：通过`index.merge.scheduler.max_thread_count`（默认`Math.min(4, Runtime.getRuntime().availableProcessors())`）控制合并线程数，避免与业务操作争资源。

### 3.5 使用注意事项
- 大批次写入时（如百万级数据），用`bulk` API代替单条写入，减少网络开销；
- 定期用`GET /index/_stats`查看`docs.count`和`store.size`，确保各分片数据量均衡；
- 段合并线程数建议设置为`2`（CPU核数充足时），避免合并任务抢占业务资源。

## 四、高频面试题
1. **集群脑裂的根本原因是什么？如何预防？**
   - 根本原因：
     ① 旧版选举协议（Zen Discovery）未强制要求初始主节点列表，网络分区时未连通节点会重新选举主节点；
     ② 心跳检测机制缺陷（默认3秒超时），可能将正常主节点误判为不可用，触发重复选举。
   - 预防措施：
     ① 协议层：升级ES7+并配置`cluster.initial_master_nodes`明确初始主节点列表；
     ② 参数层：设置`discovery.zen.minimum_master_nodes=(master节点数/2)+1`（如3节点设为2），确保多数节点认可才选举主节点；
     ③ 网络层：部署独立心跳网络，确保节点间延迟稳定<1秒。

2. **ES如何保证数据一致性？**
   - 写入一致性：
     ① 客户端请求先路由到主分片所在节点，主分片写入成功后，同步到`wait_for_active_shards`指定数量的副本分片（默认`1`，即仅主分片成功即可返回）；
     ② 若副本分片同步失败，主分片会标记该副本为不可用，后续请求不再路由至此副本。
   - 读取一致性：
     ① 优先读取主分片（强一致），若主分片不可用则读取副本分片（可能存在秒级延迟的异步同步数据）；
     ② 可通过`refresh=wait_for`参数强制刷新，确保读取到最新写入数据。

3. **高并发写入时ES的性能瓶颈在哪里？如何优化？**
   - 核心瓶颈：
     ① 分片热点：文档ID哈希分布不均，导致单个分片QPS超5万（节点CPU/IO饱和）；
     ② 内存缓冲区溢出：默认`indices.memory.index_buffer_size`为JVM堆10%，大批次写入时触发强制刷新（延迟从ms级升至s级）；
     ③ 段合并压力：高并发写入生成大量小段（<10MB），后台合并任务抢占CPU/IO资源。
   - 优化方案：
     ① 路由优化：根据业务维度（如用户ID后4位）指定`_routing`，确保分片QPS差异<20%；
     ② 缓冲区调优：将`indices.memory.index_buffer_size`提升至20%（JVM堆足够时），减少强制刷新频率；
     ③ 合并控制：设置`index.merge.scheduler.max_thread_count=2`（CPU核数≥8时），避免合并任务与业务操作争资源。

4. **动态映射和显式映射的优缺点？**
   - 动态映射（`dynamic:true`）：
     优点：无需提前定义字段类型，适合快速测试或字段类型不确定的场景；
     缺点：不同文档同一字段可能被推断为不同类型（如数字与字符串混合），导致`mapper_parsing_exception`索引失败。
   - 显式映射（`dynamic:strict`）：
     优点：强制提前定义所有字段类型（如`keyword`/`text`），从源头避免类型冲突；
     缺点：需提前规划字段类型，新增字段需通过`PUT /index/_mapping`动态添加（可能影响写入性能）。