# Redis数据类型深度解析

## 一、String（字符串）
### 核心原理  
Redis String底层基于**简单动态字符串（SDS）**实现，其核心结构体（如`sdshdr8`/`sdshdr16`等）包含`len`（已用长度）、`alloc`（总分配长度）、`flags`（编码标识）和字符数组。内存预分配策略为：字符串增长时，若新长度<1MB则加倍分配内存；若≥1MB则每次额外分配1MB，减少后续扩容次数；惰性释放则是删除操作时仅修改`len`，保留内存供后续复用，避免频繁内存分配。编码切换逻辑：纯数字且≤long范围→`int`编码（8字节）；字符串≤44字节→`embstr`编码（内存连续，一次分配）；超44字节→`raw`编码（两次分配，分别存头部和字符）。  

### 技术组成  
- 编码切换：`int`（纯数字且≤long范围）→`embstr`（字符串≤44字节）→`raw`（超44字节）。  
- 原子操作：`INCR/DECR`基于SDS的数值解析实现原子性，依赖单线程模型保证操作串行执行。  

### 注意事项  
- 内存浪费：大量小String建议用Hash聚合（如用户信息拆分为多个field），减少元数据开销。  
- 大Key风险：单String超100MB会阻塞主线程，需避免存储大文件Base64，改用分布式文件系统。  

### 使用场景  
- 计数器（文章阅读量、接口QPS）：`INCR`原子性保证计数准确。  
- 分布式Session：存储用户登录态，配合`EXPIRE`实现会话过期。  


## 二、Hash（哈希）
### 核心原理  
底层默认用**压缩列表（ziplist）**存储（当field-value总长度≤64字节且元素数≤512时），否则切换为**哈希表（dict）**。压缩列表通过连续内存块存储entry，每个entry包含`prevlen`（前一个entry长度，支持反向遍历）、`encoding`（数据类型与长度标识）、`content`（实际数据），无指针开销；哈希表则基于字典结构，每个键值对为字典节点，支持O(1)读写但节点分散导致内存碎片化。编码切换触发后（如field-value数量超512），ziplist会全量转换为dict，且转换后无法回退。  

### 技术组成  
- 编码切换：`ziplist`（field+value总长度≤64字节且元素数≤512）→`dict`（超阈值触发重编码）。  
- 操作特性：`HSET/HGET`为单field操作，`HMSET/HMGET`批量操作时需控制field数量（避免阻塞）。  

### 注意事项  
- 批量操作风险：`HMSET`一次性传入过多field会占用主线程，建议拆分多次或用Pipeline。  
- 内存优化：小对象聚合场景（如用户信息）优先用Hash，减少Key数量；大对象（如文章内容）不适合。  

### 使用场景  
- 对象存储（用户信息、商品详情）：`HSET user:1001 name "Alice" age 25` 原子性更新字段。  
- 购物车：每个用户一个Hash，field为商品ID，value为数量，`HINCRBY`实现数量增减。  


## 三、List（列表）
### 核心原理  
底层用**压缩列表**或**双向链表（linkedlist）**。压缩列表要求元素数≤512且单元素≤64字节，通过连续内存块存储entry（结构同Hash的ziplist）；双向链表每个节点含`prev`/`next`指针与字符串指针，支持O(1)头尾操作但节点分散导致内存碎片化。编码切换后（如元素数超512），ziplist转为linkedlist且无法回退，大量删除操作后需手动`DEBUG RELOAD`回收内存。  

### 技术组成  
- 编码切换：`ziplist`（元素数≤512且每个元素≤64字节）→`linkedlist`（超阈值切换）。  
- 操作特性：`LPUSH/RPOP`实现FIFO队列，`LPUSH/LPOP`实现栈结构；`LRANGE`需谨慎使用（大范围读取会阻塞）。  

### 注意事项  
- 消息队列风险：List作为MQ时无ACK机制，需结合业务保证消费幂等；高并发下`LPUSH`性能优于多个String拼接。  
- 内存回收：大量删除操作后，双向链表的内存不会自动压缩，需手动触发`DEBUG RELOAD`或重启实例。  

### 使用场景  
- 最新消息流（如微博时间线）：`LPUSH`新消息，`LRANGE 0 9`获取最新10条。  
- 异步任务队列：生产者`LPUSH`任务，消费者`BRPOP`阻塞获取任务。  


## 四、Set（集合）
### 核心原理  
底层用**整数集合（intset）**或**哈希表（dict）**。整数集合存储纯整数（支持int16/int32/int64，插入更大整数时触发全量升级，如int16→int32），内存连续无冗余；哈希表存储非整数元素，key为member、value为`NULL`（仅作去重标记），节点分散导致内存碎片化。编码切换条件：元素含非整数或数量超512时，intset转为dict且无法回退。  

### 技术组成  
- 编码切换：`intset`（元素全为整数且数量≤512）→`dict`（含非整数或超数量）。  
- 操作特性：`SADD/SREM`保证唯一性，`SINTER/SUNION`等集合运算时间复杂度为O(n)，大集合运算需异步处理。  

### 注意事项  
- 集合运算性能：千万级大集合求交/并会阻塞主线程，建议拆分小集合或用Redis Cluster分片。  
- 去重场景：用户标签系统（每个用户标签存为Set），`SADD`自动去重，`SMEMBERS`谨慎用于大集合（O(n)时间）。  

### 使用场景  
- 标签系统（用户兴趣标签）：`SADD user:tags:1001 movie music`，`SINTER`找共同兴趣用户。  
- 抽奖系统：`SADD`参与用户ID，`SRANDMEMBER`随机抽取中奖者。  


## 五、Sorted Set（有序集合）
### 核心原理  
底层用**压缩列表**或**跳表（skiplist）+ 字典（dict）**。压缩列表要求元素数≤128且单元素≤64字节，结构同Hash/List的ziplist；跳表+字典中，跳表按score排序（节点含多层级，层级由概率1/2的随机函数生成，平均层级为2），字典存member→score映射保证O(1)查询。编码切换后（如元素数超128），ziplist转为skiplist+dict且无法回退，score为双精度浮点数需注意精度丢失场景。  

### 技术组成  
- 编码切换：`ziplist`（元素数≤128且每个元素≤64字节）→`skiplist`（超阈值切换）。  
- 操作特性：`ZADD`带score插入，`ZRANGEBYSCORE`按分数范围查询，`ZREVRANK`查倒序排名；跳表层级随机生成（平均O(log n)复杂度）。  

### 注意事项  
- 分数精度：score为双精度浮点数，极端场景（如金融计算）需避免精度丢失，改用整数放大（如分转元×100）。  
- 内存优化：排行榜场景若只需Top N，用`ZREVRANGE`代替全量存储，减少内存占用。  

### 使用场景  
- 实时排行榜（游戏段位、销售榜单）：`ZADD rank:game:1001 userA 100 userB 95`，`ZREVRANGE rank:game:1001 0 9`取Top10。  
- 延迟任务：score设为任务执行时间戳，`ZRANGEBYSCORE`轮询获取到期任务。  


## 六、Stream（流）
### 核心原理
Redis 5.0新增的Stream是专为消息队列设计的类型，底层结合**基数树（radix tree）**与**列表打包（listpack）**存储。基数树按消息ID（形如`时间戳-序列号`，如`1699999999999-0`）前缀分层索引，支持高效范围查询；listpack存储消息体（含field-value对），保证内存连续性。消息ID全局唯一且单调递增，由服务端生成（避免客户端时间回拨冲突）。

### 底层结构
- 消费者组（Consumer Group）：每个组维护`last_delivered_id`（已投递给消费者的最大ID）和待确认（Pending Entries List, PEL）队列，PEL记录已投递但未ACK的消息，确保消费幂等性。
- 持久化：Stream消息默认落盘（AOF/RDB），支持断点续传；消息删除需显式调用`XDEL`，旧消息可通过`MAXLEN`策略（如`~`近似修剪）自动淘汰。

### 使用场景
- 分布式消息队列：多消费者组（如订单系统拆分为库存、物流组）并行消费，`XADD`生产消息，`XREADGROUP GROUP g1 c1 COUNT 10 BLOCK 5000 STREAMS s1 >`阻塞拉取未消费消息。
- 事件溯源：按时间线存储系统事件（如用户操作日志），`XRANGE s1 - +`全量回溯历史事件。

## 七、Vector Set（矢量集合，Redis Stack扩展）
### 核心原理
基于**矢量相似度搜索（Vector Similarity Search）**实现，底层用**分层导航小世界（HNSW）**算法构建索引，支持欧氏距离、余弦相似度等度量。矢量元素以二进制数组存储，结合Redis的内存管理机制实现高效检索。

### 底层结构
- 索引构建：HNSW通过多层跳跃图加速近邻查找，每层节点数按概率递减（类似跳表），插入新矢量时动态扩展层级；元数据存储矢量维度、距离 metric 等配置。
- 混合查询：支持矢量相似度与传统Redis数据类型（如Hash属性过滤）的联合查询，如`FT.SEARCH idx 

## 八、Bitmaps（位映射）
### 核心原理  
Redis Bitmaps本质是**String类型**的位操作扩展，底层复用SDS存储二进制位序列，每个bit对应一个布尔状态（0/1）。位操作基于`offset`（位偏移）实现原子读写：`SETBIT key offset value`设置指定偏移位的值，`GETBIT key offset`读取位值，`BITCOUNT key [start end]`统计指定区间内的置位数量。内存占用与最大offset正相关（每8位占1字节），若仅操作小范围offset（如≤1000），内存开销极低（1000位≈125字节）。  

### 底层结构  
完全复用String的SDS编码（`int`/`embstr`/`raw`），位操作通过对字节数组的位运算实现。例如，offset=10对应第2个字节（索引从0开始）的第2位（10 = 1*8 + 2），修改该位时直接操作字节数组，保证原子性（Redis单线程模型）。  

### 注意事项  
- 偏移溢出：`SETBIT`的offset无上限，但超大offset（如1e9）会导致String膨胀至GB级，需严格控制offset范围。  
- 批量操作：`BITOP`（AND/OR/XOR/NOT）支持多Key位运算，但参与运算的Key需同长度，否则自动补0可能导致内存浪费。  

### 使用场景  
- 日活统计：为每个用户设置`user:login:20241001`的Bitmaps，`SETBIT`记录登录（offset=用户ID），`BITCOUNT`统计当日活跃用户数。  
- 签到系统：用户每月签到存为`user:sign:1001:202410`，`SETBIT offset=日期 value=1`，`BITCOUNT`查全月签到天数，`BITOP`对比多月签到模式。  


## 九、HyperLogLog（基数统计）
### 核心原理  
基于**概率基数算法**实现近似去重计数，仅需12KB内存即可统计≤2⁶⁴个不同元素，标准误差约0.81%。底层采用**稀疏矩阵→稠密矩阵**的动态存储优化：小基数时用稀疏结构（仅记录非零桶）节省空间，基数超过阈值（约12k元素）时转为稠密矩阵（固定12KB）。算法通过“伯努利试验”统计最长连续0的位数（桶的寄存器值），结合调和平均估算基数。  

### 底层结构  
由多个“桶（bucket）”组成，每个桶对应一个寄存器存储最大连续0的位数。Redis对HyperLogLog的实现做了优化：稀疏模式下用哈希表记录非零桶的位置与值，稠密模式下用字节数组存储所有桶的寄存器（每个寄存器占6位，共2048个桶）。  

### 注意事项  
- 精度 trade-off：统计结果为近似值，金融级精确计数需用Set；但大基数场景（如千万级UV）HyperLogLog的内存优势碾压Set。  
- 合并操作：`PFMERGE`合并多个HyperLogLog时，时间复杂度为O(n)（n为桶数量），大数量合并需异步处理。  

### 使用场景  
- 页面UV统计：每个页面一个HyperLogLog（如`page:uv:home`），`PFADD`记录访问用户ID，`PFCOUNT`统计独立访客数；多页面合并用`PFMERGE`。  
- 行为去重统计：统计用户不同渠道的行为（如APP、H5、小程序），每个渠道一个HyperLogLog，合并后分析全渠道触达用户数。  
`