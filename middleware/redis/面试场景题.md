### Redis面试场景题

#### 1.缓存击穿、缓存穿透、缓存雪崩
- 缓存雪崩
  - 场景：系统A,每天的高峰期需要扛住5000个请求，但缓存机器意外全盘宕机，缓存挂了，大量请求全部落盘数据库，数据库扛不住报警，导致系统崩溃，系统无法恢复，用户无法正常访问
     系统A的缓存的key 在某一时间 大量失效，导致大量请求直接穿透到数据库，数据库压力过大，导致系统崩溃。
  - 解决方案：
    - 事前：Redis 高可用 主从+哨兵，Redis cluster 避免全盘崩溃，添加监控【随机时间过期，避免全盘失效】
    - 事中：本地缓存+ 限流降级 避免MYSQL被打死
    - 事后：监控报警，及时修复 Redis持久化，一旦重启，自动从磁盘加载数据 快速恢复数据
  - 综述
    ``` 用户发送一个请求，系统 A 收到请求后，先查本地 ehcache 缓存，如果没查到再查 Redis。如果 ehcache 和 Redis 都没有，再查数据库，将数据库中的结果，写入 ehcache 和 Redis 中。
    限流组件，可以设置每秒的请求，有多少能通过组件，剩余的未通过的请求，怎么办？走降级！可以返回一些默认的值，或者友情提示，或者空值。
    好处：
    数据库绝对不会死，限流组件确保了每秒只有多少个请求能通过。
    只要数据库不死，就是说，对用户来说，2/5 的请求都是可以被处理的。
    只要有 2/5 的请求可以被处理，就意味着你的系统没死，对用户来说，可能就是点击几次刷不出来页面，但是多点几次，就可以刷出来了。
    ```
- 缓存穿透
  - 场景：系统A  某一秒5000个请求，其中大部分是恶意攻击,那么恶意攻击的请求缓存中查不到，数据库也查不到，那么这种攻击场景的缓存穿透就会把数据库打死
  - 解决方案：
    - 每次从系统中只要没查到，那么缓存一个空值到缓存中去，并设置一个过期时间，那么相同的key来访问时 缓存失效前 可以从缓存中取数据
    - 在缓存前 增加布隆过滤器，将数据库中所有的数据hash映射到布隆过滤器中，并针对每个请求判断
      请求的key是否在布隆过滤器中，如果确定数据就一定不会存在于数据库中，系统可以立即返回不存在
      请求的数据的key存在于布隆过滤器[起一个初筛的作用，过滤掉大部分恶意攻击请求]中，那么继续向缓存中查询
- 缓存击穿
  - 某个 key 非常热点，访问非常频繁，处于集中式高并发访问的情况，当这个 key 在失效的瞬间，大量的请求就击穿了缓存，直接请求数据库，就像是在一道屏障上凿开了一个洞。
  不同场景下的解决方式可如下：
    - 若缓存的数据是基本不会发生更新的，则可尝试将该热点数据设置为永不过期。
    - 若缓存的数据更新不频繁，且缓存刷新的整个流程耗时较少的情况下，则可以采用基于 Redis、zookeeper 等分布式中间件的分布-式互斥锁，或者本地互斥锁以保证仅少量的请求能请求数据库并重新构建缓存，其余线程则在锁释放后能访问到新缓存。
    - 若缓存的数据更新频繁或者在缓存刷新的流程耗时较长的情况下，可以利用定时线程在缓存过期前主动地重新构建缓存或者延后缓存的过期时间，以保证所有的请求能一直访问到对应的缓存。

#### 2.Redis的并发问题
 - 多客户端同时并发写一个key, 可能本来应该先到的数据 后到了， 导致数据版本错了，或者多个客户端获取同一个key 修改值之后在写回去，只要顺序错了 数据就错了

#### 3.基于现实业务的Redis场景题

##### 3.1 商品库存扣减（高并发计数场景）
- **业务场景**：电商大促期间，商品库存需要支持万级QPS的扣减操作，传统数据库事务扣减易导致锁竞争和性能瓶颈。
- **使用Redis原因**：
  - 支持原子操作（如`DECR`命令），确保库存扣减的线程安全；
  - 内存存储+单线程模型，QPS可达10万+，远超数据库（通常1万QPS以下）；
  - 可结合Lua脚本实现“查询+扣减”原子性，避免超卖。
- **解决的问题**：高并发下库存扣减的性能瓶颈和数据一致性问题。
- **替代方案**：数据库乐观锁（通过版本号实现），但大促期间会因频繁重试导致失败率上升；Memcached（不支持原子操作，需结合CAS实现，复杂度高）。
- **具体使用**：
  ```lua
  -- Lua脚本原子扣减库存（库存≥1时扣减）
  local stock = tonumber(redis.call('GET', KEYS[1]))
  if stock and stock >= 1 then
      redis.call('DECR', KEYS[1])
      return 1
  end
  return 0
  ```
  调用示例：`EVAL script 1 product:stock:1001`
- **注意事项**：
  - 设置库存缓存的过期时间（如活动结束后自动失效），避免脏数据；
  - 定期同步缓存库存与数据库（如每5分钟），防止缓存与DB不一致；
  - 大促前通过`EXPIRE`命令延长缓存过期时间，避免活动期间缓存失效。

##### 3.2 热门文章点赞计数（高频读场景）
- **业务场景**：资讯类APP的热门文章需实时展示点赞数，用户刷新页面时需快速读取。
- **使用Redis原因**：
  - 内存存储支持微秒级读操作（读取耗时<1ms），远超数据库（通常10ms以上）；
  - 支持`INCR`（点赞）、`DECR`（取消点赞）原子命令，保证计数准确性；
  - 可结合`Pipeline`批量操作，减少网络IO（如批量处理100个点赞请求）。
- **解决的问题**：高频读场景下数据库的读压力，以及计数延迟问题。
- **替代方案**：数据库单独计数表（需加索引），但高并发下会导致主库压力过大；本地内存缓存（如Guava Cache），但无法跨应用实例共享。
- **具体使用**：
  - 点赞：`INCR article:like:10086`
  - 读取：`GET article:like:10086`
  - 批量读取10篇文章点赞数：`MGET article:like:1001 article:like:1002 ...`
- **注意事项**：
  - 对非热门文章（点赞量低），可定期（如每小时）将Redis计数落库，减少DB写压力；
  - 使用`Hash`结构存储扩展信息（如点赞用户ID集合），避免单个key过大（建议单个key不超过10MB）；
  - 监控Redis内存使用，避免因点赞数据过多导致内存溢出（可结合LRU淘汰策略）。

##### 3.3 会话存储（分布式系统共享会话）
- **业务场景**：微服务架构下，用户登录态需在多个服务（如API网关、订单服务）间共享，传统Cookie+本地Session无法跨实例使用。
- **使用Redis原因**：
  - 支持`Hash`结构存储会话信息（如用户ID、权限、过期时间），结构灵活；
  - 支持`EXPIRE`命令设置会话过期时间（如30分钟），自动清理无效会话；
  - 分布式部署（如Redis Cluster）支持跨机房会话共享，保证高可用。
- **解决的问题**：分布式系统中会话无法跨实例/服务共享的问题。
- **替代方案**：数据库存储会话（需加索引加速查询），但高并发下会成为性能瓶颈；Memcached（不支持持久化，服务重启后会话丢失）。
- **具体使用**：
  - 登录成功后存储会话：
    `HSET session:token_abc user_id 1001 username "张三" expires_at 1718928000`
    `EXPIRE session:token_abc 1800` （30分钟过期）
  - 验证会话：
    `HGETALL session:token_abc` （获取会话信息）
- **注意事项**：
  - 会话token需使用随机字符串（如UUID），避免被猜测；
  - 敏感信息（如用户密码）不要存储在会话中，仅存用户ID等必要信息；
  - 定期清理过期会话（虽Redis自动清理，但可通过`SCAN`命令手动检查避免内存泄漏）。
##### 
好的，我需要分析用户的问题“redis做mq 与kafka做mq的区别”，并按照要求生成符合JSON格式的响应。首先，用户的问题是关于Redis和Kafka作为消息队列的区别，属于技术概念的比较，没有涉及需要修改文件或执行任务的需求，因此用户意图是general_question。用户的问题使用的是中文，所以query_language是Chinese。接下来需要回答这个问题，按照markdown格式，结构清晰，涵盖核心区别点，如架构设计、适用场景、可靠性、吞吐量等。

首先，确定用户的问题类型是一般问题，需要直接回答。然后，整理Redis和Kafka作为消息队列的主要区别：

1. **架构设计**：Redis基于内存，轻量级；Kafka基于磁盘，分布式日志系统。
2. **消息持久化**：Redis依赖AOF/RDB，可能丢失数据；Kafka默认持久化，高可靠性。
3. **吞吐量**：Kafka支持百万级TPS，适合大数据场景；Redis适合万级TPS，低延迟。
4. **消息模型**：Redis支持发布订阅、队列；Kafka支持分区、消费者组，更复杂的消费模式。
5. **适用场景**：Redis适合实时性要求高、轻量级场景；Kafka适合高吞吐、持久化、离线处理。

需要将这些点组织成结构化的回答，确保清晰易懂。最后，按照JSON格式输出，确保符合所有规则，如双引号转义、无多余空格等。

### Redis作为MQ与Kafka作为MQ的核心区别

#### 1. 架构设计与定位
- **Redis**：本质是内存数据库，消息队列（MQ）是其扩展功能（如发布订阅模式、`LIST`/`STREAM`结构）。设计目标是轻量级、低延迟，适合实时性要求高但消息可靠性要求不高的场景。
- **Kafka**：专为高吞吐、高可靠的分布式消息系统设计，基于日志追加（Log Append）的磁盘存储架构，支持海量消息持久化与离线处理。

#### 2. 消息持久化与可靠性
- **Redis**：消息存储依赖内存，需通过AOF/RDB持久化到磁盘。若未开启持久化或持久化延迟，可能丢失消息（如`LIST`弹出后未及时同步）；`STREAM`结构虽支持持久化，但可靠性低于Kafka。
- **Kafka**：消息默认持久化到磁盘（通过分区副本机制），支持`acks`参数控制写入确认（如`acks=all`保证消息不丢失），可靠性更高。

#### 3. 吞吐量与延迟
- **Redis**：内存操作+单线程模型（核心命令执行），QPS可达10万级，延迟极低（微秒级），但受限于内存容量，适合小数据量、高频短消息场景。
- **Kafka**：基于磁盘顺序写+零拷贝（Zero-Copy）技术，单集群吞吐量可达百万级TPS，延迟约毫秒级（批量写入优化），适合大数据量、高吞吐场景（如日志收集、实时计算）。

#### 4. 消息模型与功能
- **Redis**：支持简单的发布订阅（Pub/Sub）、队列（`LPUSH/RPOP`）及增强版`STREAM`（支持消费者组），但消费语义仅支持“至少一次”（At Least Once），且不支持消息回溯（除非手动存储）。
- **Kafka**：支持分区（Partition）、消费者组（Consumer Group）、消息偏移量（Offset），提供“精确一次”（Exactly Once）消费语义（需结合事务），支持消息回溯（按时间/偏移量重消费）。

#### 5. 适用场景
- **Redis MQ**：实时通知（如IM消息推送）、轻量级任务队列（如秒杀库存通知）、需低延迟但允许少量消息丢失的场景。
- **Kafka MQ**：大数据管道（如日志聚合）、实时流处理（如用户行为分析）、跨系统解耦（需高可靠、可追溯的消息传递）。
