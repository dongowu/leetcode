## 全局的唯一ID

#### 应用场景
- 用户ID
- 聊天ID
- 订单ID
- 数据库主键
#### 需求
- 通常作为数据库主键，保证全局唯一，数据库在这个字段上建立聚集索引，即该字段会影响各条数据的物理存储顺序
- ID可以根据各个业务需求 尽可能的短 节省内存，数据索引效率更高，64位整数基本满足全部场景，但是具体业务具体分析
- 查询有分页和排序的需求，需要给每条数据添加一个时间字段，但是需要在上面建立普通索引，但是普通索引一般会比聚集索引慢，若能让id随时间错略有序 则可以省去时间含义的字段
- 综上 核心需求：1、全局唯一 2、按照时间错略有序 3、尽可能的短

### 方案
1. UUID ：每台机器可以产生独立的ID，理论上保证不会重复 天然分布式
   - 举例：mongodb会自动给每条数据赋予唯一的objectId，这个objectId保证了不会重复，组成成分
    ```- 4个字节 unix stamp
    - 3个字节 机器ID
    - 2个字节进程ID
    - 3个字节表示计数器
    ```
  - 缺点是ID太长 占用内存 索引查询效率低
2. 依赖数据库的自增属性保证唯一
  -  优点：
  ```
      1、简单 使用数据库的功能
      2、能保证唯一性
      3、保证递增性
      4、步长固定
  ```
  - 缺点
  ```
     1、可用性难保证，数据库一般是一主多从/读写分离，主库挂了 就玩不了了
     2、扩展性差，性能有上限：因为写入是单点，数据库主库的写性能决定ID的生成性能上限，并且难以扩展
  ```
  - 改进方案：
    - 增加主库，避免写入单点
    - 数据水平切分，保证各主库生成的ID不重复
    ![图片](http://mmbiz.qpic.cn/mmbiz/YrezxckhYOydMj2Lichnic5csTOdqI2a1mhuMcicyicr4Qgj6HSNbtS2jApdjkt8cpVrGzK75J6Kt4FtfdeD7ZzSQw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1)
    - 缺点
    ```
     1、丧失了ID生成的“绝对递增性”：先访问库0生成0,3，再访问库1生成1，可能导致在非常短的时间内，ID生成不是绝对递增的（这个问题不大，我们的目标是趋势递增，不是绝对递增）
     2、数据库的写压力依然很大，每次生成ID都要访问数据库
    ```
3. Snowflake:雪花ID
  - 核心思想是：一个long型的ID，使用其中41bit作为毫秒数，10bit作为机器编号，12bit作为毫秒内序列号
  - ![这是图片](https://camo.githubusercontent.com/c9ec98593be6d93ee262c2513a30330f72ecc3e59e6d5954ed68cdbed27536d8/687474703a2f2f3132312e34302e3133362e332f77702d636f6e74656e742f75706c6f6164732f323031352f30342f736e6f77666c616b652d36346269742e6a7067 "Magic Gardens")
  - 缺点
  ```
  没有一个全局的时钟 如果涉及时钟回拨，那么ID可能会造成重复
  ```
  - 优化方案
    ```
    基于当前机器一次批量生产出多个ID，放入id池 在新建数据记录时从id池中获取
    ```
